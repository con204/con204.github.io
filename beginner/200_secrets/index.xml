<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Securing Secrets using SealedSecrets on Amazon EKS Workshop</title>
    <link>/beginner/200_secrets/</link>
    <description>Recent content in Securing Secrets using SealedSecrets on Amazon EKS Workshop</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 15 Jul 2021 00:00:00 -0300</lastBuildDate><atom:link href="/beginner/200_secrets/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Creating and Deploying Secrets</title>
      <link>/beginner/200_secrets/deploying-secrets-variables/</link>
      <pubDate>Thu, 15 Jul 2021 00:00:00 -0300</pubDate>
      
      <guid>/beginner/200_secrets/deploying-secrets-variables/</guid>
      <description>Since 1.14, Kubectl supports the management of Kubernetes objects using Kustomize. Kustomize provides resource Generators to create Secrets and ConfigMaps. The Kustomize generators should be specified in a kustomization.yaml file. A Kustomize file for generating a Secret from literal key-value pairs looks as follows: namespace: octank secretGenerator: - name: database-credentials literals: - username=admin - password=Tru5tN0! generatorOptions: disableNameSuffixHash: true  Run the following set of commands to generate a Secret using Kubectl and Kustomize.</description>
    </item>
    
    <item>
      <title>Creating and Deploying Secrets (cont.)</title>
      <link>/beginner/200_secrets/deploying-secrets-volumes/</link>
      <pubDate>Thu, 15 Jul 2021 00:00:00 -0300</pubDate>
      
      <guid>/beginner/200_secrets/deploying-secrets-volumes/</guid>
      <description>Exposing Secrets as Volumes Secrets can be also mounted as data volumes on to a Pod and you can control the paths within the volume where the Secret keys are projected using a Pod manifest as shown below: apiVersion: v1 kind: Pod metadata: name: someName namespace: someNamespace spec: containers: - name: someContainer image: someImage volumeMounts: - name: secret-volume mountPath: &amp;#34;/etc/data&amp;#34; readOnly: true volumes: - name: secret-volume secret: secretName: database-credentials items: - key: username path: DATABASE_USER - key: password path: DATABASE_PASSWORD  With the above configuration, what will happen is:</description>
    </item>
    
    <item>
      <title>Sealed Secrets for Kubernetes</title>
      <link>/beginner/200_secrets/sealed-secrets/</link>
      <pubDate>Thu, 15 Jul 2021 00:00:00 -0300</pubDate>
      
      <guid>/beginner/200_secrets/sealed-secrets/</guid>
      <description>How it Works Sealed Secrets is composed of two parts:
 A cluster-side controller A client-side utility called kubeseal  Upon startup, the controller looks for a cluster-wide private/public key pair, and generates a new 4096 bit RSA key pair if not found. The private key is persisted in a Secret object in the same namespace as that of the controller. The public key portion of this is made publicly available to anyone wanting to use SealedSecrets with this cluster.</description>
    </item>
    
    <item>
      <title>Installing Sealed Secrets</title>
      <link>/beginner/200_secrets/installing-sealed-secrets/</link>
      <pubDate>Thu, 15 Jul 2021 00:00:00 -0300</pubDate>
      
      <guid>/beginner/200_secrets/installing-sealed-secrets/</guid>
      <description>Installing the kubeseal Client For Linux x86_64 systems, the client-tool may be installed into /usr/local/bin with the following command:
wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.16.0/kubeseal-linux-amd64 -O kubeseal sudo install -m 755 kubeseal /usr/local/bin/kubeseal For MacOS systems, the client-tool is installed as follows:
brew install kubeseal Installing the Custom Controller and CRD for SealedSecret Install the SealedSecret CRD, controller and RBAC artifacts on your EKS cluster as follows:
wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.16.0/controller.yaml kubectl apply -f controller.yaml Check the status of the controller pod.</description>
    </item>
    
    <item>
      <title>Sealing Your Secrets</title>
      <link>/beginner/200_secrets/sealing-secrets/</link>
      <pubDate>Thu, 15 Jul 2021 00:00:00 -0300</pubDate>
      
      <guid>/beginner/200_secrets/sealing-secrets/</guid>
      <description>First, let&amp;rsquo;s delete the database-credentials Secret and Pod resources that was created earlier in this module and deployed to the octank namespace in the cluster. After this operation, the only Secret that should exist in that namespace will be that of the token generated by Kubernetes for the default service account associated with the octank namespace.
kubectl delete pod pod-variable pod-volume -n octank kubectl delete secret database-credentials -n octank kubectl get secret -n octank Output: NAME TYPE DATA AGE default-token-gv8nr kubernetes.</description>
    </item>
    
    <item>
      <title>Managing the Sealing Key</title>
      <link>/beginner/200_secrets/managing-sealing-key/</link>
      <pubDate>Thu, 15 Jul 2021 00:00:00 -0300</pubDate>
      
      <guid>/beginner/200_secrets/managing-sealing-key/</guid>
      <description>Without the private key that is managed by the controller, there is no way to decrypt the encrypted data within a SealedSecret. In the event that you are trying to restore the original state of a cluster after a disaster or you want to leverage GitOps workflow to deploy the Kubernetes resources, including SealedSecrets, from a Git repository and stand up a separate instance of an EKS cluster, the controller deployed in the new cluster must use the same private key to be able to unseal the SealedSecrets.</description>
    </item>
    
    <item>
      <title>Clean Up</title>
      <link>/beginner/200_secrets/cleaning/</link>
      <pubDate>Thu, 15 Jul 2021 00:00:00 -0300</pubDate>
      
      <guid>/beginner/200_secrets/cleaning/</guid>
      <description>Delete all the resources created in this module.
cd ~/environment/secrets kubectl delete Secret --all -n octank kubectl delete SealedSecret --all -n octank kubectl delete pod --all -n octank kubectl delete -f controller.yaml kubectl delete namespace octank </description>
    </item>
    
  </channel>
</rss>
